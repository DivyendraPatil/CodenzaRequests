#include <stdio.h> 
#include <stdlib.h>
#include <syslog.h> // For writing logs to syslog
#include <dirent.h> // For directory maniplulation and checking
#include <sys/file.h>  // For making sure one instance of file is running
#include <errno.h> 
#include <stdbool.h> // For true and false
#include <unistd.h>
#include <signal.h> // For handling sigkill and sigstop

char successpid[] = "Process ID is greater than 0.. starting to log file";
char failurepid[] = "Process ID is less than 0, hence exit.";
char ssid[] = "Session ID is less than 0.";
char direxists[] = "Directory exists";
char rexists[] = "Root directory exists";
char nodir[] = "Directory does not exists";
char program_name[] = "daemon_program";
char sig_kill[] = "SIGKILL Received. Killing daemon";
char sig_stop[] = "SIGSTOP Received. Stopping daemon";
char sig_usr[] = "SIGUSR Received. Stopping daemon";

/* 

openlog opens or reopens a connection to Syslog in preparation for 
submitting messages.
- LOG_PID: When on, openlog sets up the connection so that a syslog on 
this connection inserts the calling processâ€™ Process ID (PID) into the message. 
- LOG_USER: (default) generic user-level messages
# http://fibrevillage.com/sysadmin/70-how-to-syslog-your-program-output

*/

void sig_handler(int signo){
    openlog ("daemon_program", LOG_PID , LOG_USER);

    switch(signo){
        case SIGUSR1:
            syslog(LOG_INFO,"%s", sig_usr);
            break;
        case SIGKILL:
            syslog(LOG_INFO,"%s", sig_kill);
            break;
        case SIGSTOP:
            syslog(LOG_INFO,"%s", sig_stop);
            break;
    }

    exit(EXIT_SUCCESS);
    closelog ();
}

void write_status(char status[],int pid){
	openlog ("daemon_program", LOG_PID , LOG_USER);
	if (pid < 0) {
		syslog(LOG_ERR,"%s", status);
	} else {
		syslog(LOG_INFO,"%s", status);
	}
	closelog ();
}

int main(void) {

    /*
     If a process wishes to handle certain signals then in the code, 
     the process has to register a signal handling function to the kernel.
     The signal handler function has void return type and accepts a signal 
     number corresponding to the signal that needs to be handled.
     And here we have user defined signals that can be sent and handled.
    */

    signal(SIGUSR1, sig_handler);
    signal(SIGKILL, sig_handler);
    signal(SIGSTOP, sig_handler);

    int pid_file = open("/usr/daemon_program.pid", O_CREAT | O_RDWR, 0666);
    int return_code = flock(pid_file, LOCK_EX | LOCK_NB);
    if(return_code) {
        if(EWOULDBLOCK == errno){
            syslog(LOG_ERR,"Daemon already running. Stopping this run and letting the first one to run");
            exit(EXIT_SUCCESS);
        }
    }

/* 
The pid_t data type stands for process identification and it is used to 
represent process ids. Whenever, we want to declare a variable that is 
going to be deal with the process ids we can use pid_t data type.	
*/

	pid_t process_id, session_id;
	pid_t pid,sid;

	/* Fork off the parent process and save a copy*/       
    process_id = fork();
	pid = process_id;

    if (process_id < 0) {
    	write_status(failurepid,process_id);
        exit(EXIT_FAILURE);
    }

/* Terminate from the parent process */

    if (process_id > 0) {
    	write_status(successpid,process_id);
    	exit(EXIT_SUCCESS);
    }

/* 
To avoid the child process becomes an orphan in the system,
the child process must get a unique SID from the kernel to work
*/

/* Create a new SID for the child process and save a copy */
    session_id = setsid();
	sid = session_id;
    if (session_id < 0) {
        write_status(ssid,sid);
        exit(EXIT_FAILURE);
    }

/* Fork off AGAIN*/    
/*
The PID != SID which means that our process is 
NOT the session leader (because of the second fork())
Because PID != SID our process can't take control of a TTY again
*/   
    process_id = fork();
	pid = process_id;

    if (process_id < 0) {
    	write_status(failurepid,process_id);
        exit(EXIT_FAILURE);
    }

/* Terminate from the parent process */
    if (process_id > 0) {
    	write_status(successpid,process_id);
    	exit(EXIT_SUCCESS);
    }


/* 
The user file-creation mode mask (umask) is use to determine the file 
permission for newly created files. It can be used to control the default 
file permission for new files. It is a four-digit octal number. 

In order to write anything in C, the file mode mask (umask) should be 
checked or defined so that anything can be read/written to properly.
*/	

/* 
Since we are using the default logging mechanism and not writing to 
any other file to log the program. We do not need to set the umask. 
But, setting the umask to 0, we will have full access to the files 
generated by the daemon. Even if we aren't planning on using any files, 
it is a good idea to set the umask here anyway, 
just in case we will be accessing files on the filesystem.
 */

    umask(0);

/*
The current working directory should be changed to some place 
that is guaranteed to always be there.
*/

    if ((chdir("/")) < 0) {
        write_status(rexists,1);
    }

 /* Since a daemon cannot use the terminal, these file descriptors are
    redundant and a potential security hazard.
    so closing the standard file descriptors */
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    while (true) {
    	// Check if /usr directory exists
    	DIR* dir = opendir("/usr");
		if (dir) {
		    /* Directory exists. */
		    write_status(direxists,1);
		    closedir(dir);
            sleep(30);
		} else {
			/* Directory does not exist. */
			write_status(nodir,-1);
		}
    }

    return 0;
}




